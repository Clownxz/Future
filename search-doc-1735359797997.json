{"searchDocs":[{"title":"Result","type":0,"sectionRef":"#","url":"/luau-futures/api/Result","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Result","url":"/luau-futures/api/Result#functions","content":" ","version":null,"tagName":"h2"},{"title":"ok​","type":1,"pageTitle":"Result","url":"/luau-futures/api/Result#ok","content":"&lt;/&gt; Result.ok(...: U...) → Result&lt;never,U...&gt; Creates a new Result of the Ok type.  ","version":null,"tagName":"h3"},{"title":"err​","type":1,"pageTitle":"Result","url":"/luau-futures/api/Result#err","content":"&lt;/&gt; Result.err(errValue: E) → Result&lt;E,never&gt; Creates a new Result of the Err type.  ","version":null,"tagName":"h3"},{"title":"isOk​","type":1,"pageTitle":"Result","url":"/luau-futures/api/Result#isOk","content":"&lt;/&gt; Result:isOk() → boolean Checks whether the Result is of the Ok type.  ","version":null,"tagName":"h3"},{"title":"isErr​","type":1,"pageTitle":"Result","url":"/luau-futures/api/Result#isErr","content":"&lt;/&gt; Result:isErr() → boolean Checks whether the Result is of the Err type.  ","version":null,"tagName":"h3"},{"title":"unwrapOk​","type":1,"pageTitle":"Result","url":"/luau-futures/api/Result#unwrapOk","content":"&lt;/&gt; Result:unwrapOk() → U... Unwraps the results of an Ok Result. DANGER Make sure you use Result:isOk before using this method. if result:isOk() then local result = result:unwrapOk() end   ","version":null,"tagName":"h3"},{"title":"unwrapErr​","type":1,"pageTitle":"Result","url":"/luau-futures/api/Result#unwrapErr","content":"&lt;/&gt; Result:unwrapErr() → E Unwraps the results of an Err Result. DANGER Make sure you use Result:isErr before using this method. if result:isErr() then local err = result:unwrapErr() end  ","version":null,"tagName":"h3"},{"title":"Poll","type":0,"sectionRef":"#","url":"/luau-futures/api/Poll","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Poll","url":"/luau-futures/api/Poll#functions","content":" ","version":null,"tagName":"h2"},{"title":"ok​","type":1,"pageTitle":"Poll","url":"/luau-futures/api/Poll#ok","content":"&lt;/&gt; Poll.ok(...: U...) → Poll&lt;never,U...&gt; Creates a Poll with an Ok result.  ","version":null,"tagName":"h3"},{"title":"err​","type":1,"pageTitle":"Poll","url":"/luau-futures/api/Poll#err","content":"&lt;/&gt; Poll.err(errValue: E) → Poll&lt;E,never&gt; Creates a Poll with an Err result.  ","version":null,"tagName":"h3"},{"title":"notReady​","type":1,"pageTitle":"Poll","url":"/luau-futures/api/Poll#notReady","content":"&lt;/&gt; Poll.notReady() → Poll&lt;never,never&gt; Creates a Poll which status is not ready.  ","version":null,"tagName":"h3"},{"title":"isReady​","type":1,"pageTitle":"Poll","url":"/luau-futures/api/Poll#isReady","content":"&lt;/&gt; Poll:isReady() → boolean Checks whether the Result of a Poll is ready. local poll = future:poll() if poll:isReady() then local result = poll:unwrap() -- ... end   ","version":null,"tagName":"h3"},{"title":"isPending​","type":1,"pageTitle":"Poll","url":"/luau-futures/api/Poll#isPending","content":"&lt;/&gt; Poll:isPending() → boolean Checks whether the Result of a Poll is pending. local poll = future:poll() if poll:isPending() then continue end   ","version":null,"tagName":"h3"},{"title":"unwrap​","type":1,"pageTitle":"Poll","url":"/luau-futures/api/Poll#unwrap","content":"&lt;/&gt; Poll:unwrap() → Result&lt;E,U...&gt; Checks whether the Result of a Poll is ready. local poll = future:poll() if poll:isReady() then local result = poll:unwrap() -- ... else local result = poll:unwrap() --! Errors -- Error: Attempt to unwrap a pending future end  ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Poll","url":"/luau-futures/api/Poll##","content":"Type\tDescriptionAttempt to unwrap a pending future\tTo prevent this, use Poll:isReady() or Future:await() to ensure the Result is ready. ","version":null,"tagName":"h3"},{"title":"Future","type":0,"sectionRef":"#","url":"/luau-futures/api/Future","content":"","keywords":"","version":null},{"title":"Functions​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#new","content":"&lt;/&gt; Future.new( callback: (T...) → U..., ...: T... ) → Future&lt;E,U...&gt; Creates a new Future, taking an asynchronous callback and parameters to pass into that callback.  ","version":null,"tagName":"h3"},{"title":"after​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#after","content":"&lt;/&gt; Future:after(fn: ( Result&lt;E, U...&gt; ) → Future&lt;E,T...&gt;) → Future&lt;E,T...&gt; After completion, passes the Result of the current future to the closure, returning a new Future.  ","version":null,"tagName":"h3"},{"title":"andThen​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#andThen","content":"&lt;/&gt; Future:andThen(fn: &lt;T&gt;(U...) → Future&lt;E,T...&gt;) → Future&lt;E,T...&gt; After successfully resolving, create and execute another Future created within the closure, with the Ok result passed in the closure arguments, otherwise it is never executed.  ","version":null,"tagName":"h3"},{"title":"await​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#await","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Future:await() → Result&lt;E,U...&gt; Yields until the Future finishes execution, then returns the result. WARNING Because this is a yielding method, it is suggested that it is only used within Futures, as opposed to the main thread. See Future:poll for the recommended way of executing Futures.  ","version":null,"tagName":"h3"},{"title":"inspectErr​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#inspectErr","content":"&lt;/&gt; Future:inspectErr(fn: (E) → ()) → Future&lt;E,U...&gt; Allows you to read the error value of a Future before passing it on.  ","version":null,"tagName":"h3"},{"title":"inspectOk​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#inspectOk","content":"&lt;/&gt; Future:inspectOk(fn: (U...) → ()) → Future&lt;E,U...&gt; Allows you to read the success value of a Future before passing it on.  ","version":null,"tagName":"h3"},{"title":"join​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#join","content":"&lt;/&gt; Future:join(otherFuture: Future&lt;E,T...&gt;) → Future&lt;never,{ Result&lt;E, never&gt; | ( U..., T... ) }&gt; Joins the results of two futures into a table. Futures of different types, Err and Ok will still have their results joined into a table. Results of type Ok will be unwrapped in the table, whereas Results of type Err will not be unwrapped and will be added as Result&lt;E, never&gt; in the table.  ","version":null,"tagName":"h3"},{"title":"joinAll​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#joinAll","content":"&lt;/&gt; Future:joinAll(...: Future&lt;E,...any&gt;) → Future&lt;never,{ Result&lt;E, never&gt; | ...any }&gt; Joins the results of two or more futures into a table.  ","version":null,"tagName":"h3"},{"title":"mapErr​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#mapErr","content":"&lt;/&gt; Future:mapErr(fn: (E) → T) → Future&lt;T,U...&gt; Maps the type of the Err result of a Future.  ","version":null,"tagName":"h3"},{"title":"mapOk​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#mapOk","content":"&lt;/&gt; Future:mapOk(fn: (U...) → T...) → Future&lt;E,T...&gt; Maps the type of the Ok result of a Future.  ","version":null,"tagName":"h3"},{"title":"orElse​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#orElse","content":"&lt;/&gt; Future:orElse(fn: (E) → Future&lt;E,U...&gt;) → Future&lt;E,U...&gt; On Err, executes another Future of the same type.  ","version":null,"tagName":"h3"},{"title":"unwrapOrElse​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#unwrapOrElse","content":"&lt;/&gt; Future:unwrapOrElse(fn: (E) → U...) → Future&lt;never,U...&gt; On Err, the result is passed to the closure to create a Ok result, then returns a Future with that Ok result.  ","version":null,"tagName":"h3"},{"title":"poll​","type":1,"pageTitle":"Future","url":"/luau-futures/api/Future#poll","content":"&lt;/&gt; Future:poll() → Poll&lt;E,U...&gt; Executes the Future on it's next resumption point, returning Result::Pending if it is not ready yet or Result::Ready if it is ready. DANGER Polling a Future that is ready will return the same result. This will however not be guaranteed behavior, and you should avoid polling a Future that is already ready. ","version":null,"tagName":"h3"},{"title":"Installation","type":0,"sectionRef":"#","url":"/luau-futures/docs/installation","content":"","keywords":"","version":"Next"},{"title":"Wally​","type":1,"pageTitle":"Installation","url":"/luau-futures/docs/installation#wally","content":" [dependencies] Futures = &quot;yetanotherclown/luau-futures@^2.0.0-beta.3&quot;   note Wally does not export types automatically and will display a type-error in one of the Dependencies. To fix this, see https://github.com/JohnnyMorganz/wally-package-types.  ","version":"Next","tagName":"h2"},{"title":"Pesde​","type":1,"pageTitle":"Installation","url":"/luau-futures/docs/installation#pesde","content":" [dependencies] Futures = { name = &quot;yetanotherclown/luau_futures&quot;, version = &quot;^2.0.0-beta.3&quot;, target = &quot;luau&quot; }   Or, you can run pesde add yetanotherclown/luau_futures --target luau --alias Futures.  ","version":"Next","tagName":"h2"},{"title":"GitHub Releases​","type":1,"pageTitle":"Installation","url":"/luau-futures/docs/installation#github-releases","content":" You can also find .rbxm files for use within Studio directly within GitHub Releases.  Get the Latest Release. ","version":"Next","tagName":"h2"},{"title":"Typechecking Guide","type":0,"sectionRef":"#","url":"/luau-futures/docs/typechecking","content":"","keywords":"","version":"Next"},{"title":"Future vs FutureLike Types​","type":1,"pageTitle":"Typechecking Guide","url":"/luau-futures/docs/typechecking#future-vs-futurelike-types","content":" The Futures library exports two types because of these restrictions.FutureLike should be used when your being given a future, such as in a function with a future as a parameter. The Future type should be used when returning a future, such as in a function return.  Example usage,  function Class:method&lt;E, U...&gt;(future: Futures.FutureLike&lt;E, U...&gt;): Futures.Future&lt;E, U...&gt; return future:andThen(function(...) -- ... end) :: any end   note To avoid recursive type restrictions, there are internally multiple types likeFutureFirst, FutureNext, FutureLast and FutureExhausted. The Futures.Future type is just FutureFirst, so when you use that type it will expect a FutureFirst which is the first type you get when creating a future with Future.new(). If you are chaining a future in a function that returns one, you can annotate the return type to be Futures.Future and then typecast the returned future with :: any like in the example.  In the Future, Futures.FutureLike will be deprecated, but it will remain available for backwards compatibility.  ","version":"Next","tagName":"h2"},{"title":"Join Methods​","type":1,"pageTitle":"Typechecking Guide","url":"/luau-futures/docs/typechecking#join-methods","content":" Currently, the Luau type solver cannot properly type the join methods. So for now, they will always return an exhausted future.  ","version":"Next","tagName":"h2"},{"title":"UnwrapOrElse​","type":1,"pageTitle":"Typechecking Guide","url":"/luau-futures/docs/typechecking#unwraporelse","content":" [Future:unwrapOrElse] should return the type Future&lt;never, U...&gt;. However, due to recursive type restrictions, it will return Future&lt;E, U...&gt;.  You should make a mental note that using this method will never error, and write your code accordingly.  ","version":"Next","tagName":"h2"},{"title":"Getting Around Exhaustion​","type":1,"pageTitle":"Typechecking Guide","url":"/luau-futures/docs/typechecking#getting-around-exhaustion","content":" So, you have an exhausted future that you want to typecheck. You can use type annotations and type casts to get around exhausted futures.  local newFuture: Future&lt;string, number, number, number&gt; = exhaustedFuture:andThen(function(...) -- ... return 1, 2, 3 end) :: any  ","version":"Next","tagName":"h2"},{"title":"Luau Futures","type":0,"sectionRef":"#","url":"/luau-futures/docs/intro","content":"Luau Futures A future represents a read-only asynchronous value, one that may not have finished computation yet. A basic future could look like: local Futures = require(&quot;@packages/Futures&quot;) local Future = Futures.Future local myFuture = Future.new(function() yield() return 1, 2, 3 end) When you create a future, it wont begin execution until it is either polled or awaited. Polling will advance the future to it's next resumption point every time that it is called, returning a [Poll] to let you check the status of the future. If the Poll is ready, you can also unwrap it to get the [Result]. local poll = myFuture:poll() if poll:isReady() then local result = poll:unwrap() -- Handle result end Awaiting a future will yield the current thread until the future finishes execution. As such, it is recommended that you only use the await method within other futures, preferring to use poll instead. local result = myFuture:await() -- Handle result To read the result, you can use [Result:isOk] or [Result:isErr] to check what type the Result is. You can then use [Result:unwrapOk] or [Result:unwrapErr] to get the value of the result. if result:isOk() then print(result:unwrapOk()) -- 1, 2, 3 elseif result:isErr() then warn(result:unwrapErr()) -- An error occurred end There are also several other methods for chaining, combining, and mapping futures, as well as other utilities for working with futures. It is suggested to read the API Documentation for more information about these methods.","keywords":"","version":"Next"}],"options":{"id":"default"}}