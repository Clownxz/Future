"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[177],{9854:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>a});const r=JSON.parse('{"id":"typechecking","title":"Typechecking Guide","description":"A guide on Typechecking Futures","source":"@site/docs/typechecking.md","sourceDirName":".","slug":"/typechecking","permalink":"/luau-futures/docs/typechecking","draft":false,"unlisted":false,"editUrl":"https://github.com/YetAnotherClown/luau-futures/edit/master/docs/typechecking.md","tags":[],"version":"current","frontMatter":{"title":"Typechecking Guide","description":"A guide on Typechecking Futures"},"sidebar":"defaultSidebar","previous":{"title":"Installation","permalink":"/luau-futures/docs/installation"}}');var u=n(4848),s=n(8453);const i={title:"Typechecking Guide",description:"A guide on Typechecking Futures"},o=void 0,c={},a=[{value:"Future vs FutureLike Types",id:"future-vs-futurelike-types",level:2},{value:"Join Methods",id:"join-methods",level:2},{value:"UnwrapOrElse",id:"unwraporelse",level:2},{value:"Getting Around Exhaustion",id:"getting-around-exhaustion",level:2}];function d(e){const t={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,u.jsxs)(u.Fragment,{children:[(0,u.jsx)(t.p,{children:"Currently, in the Luau type solver, there are restrictions placed on recursive types. Luau Futures works around this, by allowing you to chain up\r\nto 3 recursive functions (andThen, map, join, etc.) before the types are exhausted."}),"\n",(0,u.jsx)(t.h2,{id:"future-vs-futurelike-types",children:"Future vs FutureLike Types"}),"\n",(0,u.jsxs)(t.p,{children:["The Futures library exports two types because of these restrictions.\r\n",(0,u.jsx)(t.code,{children:"FutureLike"})," should be used when your being given a future, such as in a\r\nfunction with a future as a parameter.\r\nThe ",(0,u.jsx)(t.code,{children:"Future"})," type should be used when returning a future, such as in a\r\nfunction return."]}),"\n",(0,u.jsx)(t.p,{children:"Example usage,"}),"\n",(0,u.jsx)(t.pre,{children:(0,u.jsx)(t.code,{className:"language-lua",children:"function Class:method<E, U...>(future: Futures.FutureLike<E, U...>): Futures.Future<E, U...>\r\n    return future:andThen(function(...)\r\n        -- ...\r\n    end) :: any\r\nend\n"})}),"\n",(0,u.jsxs)(t.admonition,{type:"note",children:[(0,u.jsxs)(t.p,{children:["To avoid recursive type restrictions, there are internally multiple types like\r\n",(0,u.jsx)(t.code,{children:"FutureFirst"}),", ",(0,u.jsx)(t.code,{children:"FutureNext"}),", ",(0,u.jsx)(t.code,{children:"FutureLast"})," and ",(0,u.jsx)(t.code,{children:"FutureExhausted"}),"."]}),(0,u.jsxs)(t.p,{children:["The ",(0,u.jsx)(t.code,{children:"Futures.Future"})," type is just ",(0,u.jsx)(t.code,{children:"FutureFirst"}),", so when you use that type it\r\nwill expect a ",(0,u.jsx)(t.code,{children:"FutureFirst"})," which is the first type you get when creating\r\na future with ",(0,u.jsx)(t.code,{children:"Future.new()"}),"."]}),(0,u.jsxs)(t.p,{children:["If you are chaining a future in a function that returns one, you can annotate\r\nthe return type to be ",(0,u.jsx)(t.code,{children:"Futures.Future"})," and then typecast the returned future\r\nwith ",(0,u.jsx)(t.code,{children:":: any"})," like in the example."]})]}),"\n",(0,u.jsxs)(t.p,{children:["In the Future, ",(0,u.jsx)(t.code,{children:"Futures.FutureLike"})," will be deprecated, but it will remain\r\navailable for backwards compatibility."]}),"\n",(0,u.jsx)(t.h2,{id:"join-methods",children:"Join Methods"}),"\n",(0,u.jsx)(t.p,{children:"Currently, the Luau type solver cannot properly type the join methods.\r\nSo for now, they will always return an exhausted future."}),"\n",(0,u.jsx)(t.h2,{id:"unwraporelse",children:"UnwrapOrElse"}),"\n",(0,u.jsxs)(t.p,{children:["[Future",":unwrapOrElse","] should return the type ",(0,u.jsx)(t.code,{children:"Future<never, U...>"}),". However,\r\ndue to recursive type restrictions, it will return ",(0,u.jsx)(t.code,{children:"Future<E, U...>"}),"."]}),"\n",(0,u.jsx)(t.p,{children:"You should make a mental note that using this method will never error, and\r\nwrite your code accordingly."}),"\n",(0,u.jsx)(t.h2,{id:"getting-around-exhaustion",children:"Getting Around Exhaustion"}),"\n",(0,u.jsx)(t.p,{children:"So, you have an exhausted future that you want to typecheck.\r\nYou can use type annotations and type casts to get around exhausted\r\nfutures."}),"\n",(0,u.jsx)(t.pre,{children:(0,u.jsx)(t.code,{className:"language-lua",children:"local newFuture: Future<string, number, number, number> = exhaustedFuture:andThen(function(...)\r\n    -- ...\r\n    return 1, 2, 3\r\nend) :: any\n"})})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,u.jsx)(t,{...e,children:(0,u.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var r=n(6540);const u={},s=r.createContext(u);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(u):e.components||u:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);